---
layout: post
title: OS - System Structure & program Excution
category: OS(operating system)
tags: [OS, 운영체제]
comments: true
---
<!----------------- 탬플릿
## forEach
### 설명
[MDN](http://naver.com)
```javascript

```
<center>
 <figure>
 <img src="/assets/post-img/git/git_diff.png" alt="views">
 <figcaption>cat을 통해서 git diff 결과를 표시</figcaption>
 </figure>
 </center>
------------------->
> kocw 이화여대 운영체제 강의를 듣고 정리했습니다.

## 컴퓨터 시스템 구조
<center>
<figure>
<img src="/assets/post-img/os/컴퓨터시스템구조.png" alt="views">
<figcaption>컴퓨터 시스템 구조</figcaption>
</figure>
</center>

i/o 장치는 각각 디바이스를 전담하는 디바이스 컨트롤러가 붙어있음
i/o 장치를 통제하는것은 디바이스 컨트롤러가 함
작은 cpu 역활
i/o 컨트롤러도 메모리 같은 공간이 필요함 로컬 버퍼라고 부름
cpu는 memory에서 인터렉터가 걸린 인스트럭션을 가져다가 처리해주는 역할만 함
interrupt line 은 

cpu와 i/o 장치는 서로 처리속도에서 엄청난 차이가 남

cpu에는 cpu보다 더 빠른register가 있음
cpu에는 mode bit이 있음
운영체제 프로그램인지 사용자 프로그램인지 구분해줌

interrupt line이란 것이 cpu에 있는대 cpu는 항상 메모리에 있는 인스트럭션만 실행함
메모리에 있는 인스트럭션을 순차적으로 실행
키보드 입력이라던지 뭐가 끝낫다던지 하는것은 interrupt line을 통해 알게함
프로그램이 실행되다가 scnaf를 통해 입력을 받을수도 잇고 파일을 읽어와야 하는 상황이 올수도 잇음
프로그램을 작성할 때에 메모리만 가지고 작성하는것이 아니라 디스크 에 읽기 쓰고 하는 경우가 있음

cpu는 io 디바이스에 직접 접근 못함 메모리에 있는 인스트럭션만 접글할 수 있음
i/o 디바이스에서 정보가 필요하면 디바이스 컨트롤러에게 일을 시킴
디스크는 일을 하면서 버퍼에 저장시켜놈
이때 cpu는 놀지않고 메모리에 있는 다음 인스트럭션을 실행시킴 
cpu는 빠른 일군이라 계속 일만함 계속 넘어가면서 
아주 짧은 시간 간격으로 인트럭션을 처리하기 떄문에 
매우 빠르게 일을 처리해 주기 때문에 실시간으로 처리되는거처럼 보임
cpu에게 무한 루프를 도는 프로그램을 도는 프로그램을 주게되면 안되서
타이머라는 하드웨어를 두고있음.
타이머는 특정 프로그램이 cpu를 독점하는 것을 막기위해 잇음
처음에는 운영체제가 cpu를 가지고 있다가 사용자 프로그램이 실행되면 타이머에 값을 세팅 한후 cpu를 넘겨줌
프로그램은 cpu를 계속 쓸수잇는게 아니라 수십ms시간 정도에 시간을 주면서 cpu를 넘겨줌 
그러다가 세팅된 시간이 되면 타이머가 cpu에게 인터럽트를 검 세팅해논 시간이 끝낫다고
cpu는 인스트럭션을 실행하고 끝나고나면 인터럽트 라인을 체크함 없으면 다음 인스트럭션 실행하고
인터럽트 라인이 있으면 하던일을 먼추고 cpu제어권이 프로그램으로 부터 os에게 cpu제어권이 자동으로 넘어감
운영체제가 프로그램으로 cpu를 자유롭게 줄순 잇지만 뻇지는 못함
cpu를 줫기떄문에..
운영체제가 아무리 똑똑해도 뺏을 방법이 없어 
그래서 timer를 둬서 타이머 인터럽트를 줘서 사용자 프로그램으로 부터 cpu를 뻇어옴
운영체제가 cpu를 얻게되면 타이머를 다시 세팅하고 다음 프로그램에게 cpu를 넘겨줌
이걸 반복을 함 
n개의 프로그램이 있다면 다 반복하고 처음으로 돌아오고 이런식으로 처리함
사용자 프로그램은 본인이 직접 io를 접근할수 없음 이건 os를 통해서만 처리해야함 
프로그램이 io를 접근해야한다면 스스로 운영체제에게 cpu를 넘겨주면 운영체제가 해당하는 작업을
io 컨트롤러에게 시킴
그리고 오래걸리니깐 요청한 프로그램한테 넘기는게 아니라 다음 프로그램에게 넘김
그럼 요청한 프로그램은 io 컨트롤러가 요청한 작업이 끝나서 cpu에 인터럽트를 걸어두면 그때 io 처리된 것과 함께 처리가 다됫으니 요청한 프로그램에게 cpu가 넘어감  

## Mode bit
- 사용자 프록그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요
- **Mode bit**을 통해 하드웨어적으로 두 가지 모드의 **operation** 지원
- 1 사용자모드: 사용자 프로그램 수행
    - i/o 제어 불가능
    - 한정된 인스트럭션만 실행 가능함
- 0 모니터 모드*: OS 코드 수행
    - 모든 명령을 수행 가능
    - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 '**특권명령**'으로 규정
    - Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꿈
    - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅

***모니터모드(= 커널 모드, 시스템 모드)**
<center>
<figure>
<img src="/assets/post-img/os/modebit.png" alt="views">
<figcaption></figcaption>
</figure>
</center>

## Timer
- 타이머
    - 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
    - 타이머는 매 클럭 틱 때마다 1씩 감소
    - 타이머 값이 0이 되면 타이머 인터럽트 발생
    - CPU를 특정 프로그램이 독점하는 것으로부터 보호
- 타이머는 time sharing을 구현하기 위해 널리 이용됨
- 타이머는 현재 시간을 계산하기 위해서도 사용

## Device Controller
- I/O device controller
    - 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
    - 제어 정보를 위해  control register, status register를 가짐
    - local buffer를 가짐(일종의 dataregister)
    - I/O는 실제로 device와 local buffer 사이에서 일어남
        - local buffer에 데이터를 넣고 device conroller에게 처리하라고 시킴
    - Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림

**device driver(장치구동기)**

: OS 코드 중 각 장치별 처리루틴 -> **software**

**device controller(장치제어기)**

: 각 장치를 통제하는 일종의 작은 CPU -> **hardware**

디바이스를 접근하기 위한 디바이스 드라이버

이렇게 하나씩 인터럽트를 걸려다 보니깐 cpu가 인터럽트를 너무 많이 당함
그래서 DMA(Direct Memory Access)를 사용함
DMA컨트롤러를 두개되면 메로리를 직접 접근 가능함
둘이서 특정  메모리 영역을 접근하게되면 메모리 컨트롤러는 그런걸 중재하는 역활을 함
DMA는 왜달앗냐면 I/O장치가 너무 자주 인터럽트를 걸어 방해가 많이됌 그걸 막기 위해
DMA는 중간 중간 I/O장치의 요청이 CPU의 인터럽트를 거는게 아니라 DMA가 I/O가 처리한 내용을 메모리에 직접 처리를 하고 CPU에 인터럽트를 걸어서 한번에 처리될수 있게 해줌

cpu의 숙명은 본인이 이번에 실행해야될 인스트럭션 주소를 프로그램 카운터라는 레지스터가 가지고잇음
매번 그 인스트럭션만 실행하는게 cpu의 운명이야! 
인스트럭션 중에서 io장치를 접근해야 하는 상황이 오면 디바이스 드라이버를 통해서 명령을 하게됌
디스크에서 실제로 헤드를 움직여서 하는건 아님
디스크 컨트롤러가 하는거임
cpu는 메모리의 지시를 받아서 하는거고
디스크는 디스크 안의 펌웨어가 디바이스 컨트롤러 를 제어하는 언어는 따로잇음
cpu는 직접 뭔가 할수가 없고 메뉴얼 대로 일을 함
메뉴얼엔 메모리 몇번지에 일을 해야되는지 적혀있음 얘는 그냥 일하는거임
일하고나면 다음 메뉴얼에 다음페이지에 있는 인스트럭션을 실행함 반복하는거임 병신이네 ㅋ
이친구의 통제를 운영체제가 함 
하다가프로그램에게 넘겨주고 받아오고 그럼 

## 입출력(I/O)의 수행
- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 I/O를 하는가?
    - 시스템 콜(system call)
        - 사용자 프로그램은 운영체제에게 I/O 요청
    - trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
    - 제어권이 인터럽트 벡터가 가리키는 입터럽트 서비스 루틴으로 이동
    - 올바른 I/O요청인지 확인후 I/O수행
    - I/O완료 시 제어권을 시스템콜 다음 명령으로 옮김

운영체제에게 시스템 함수를 수행하도록 요청하는것은 시스템 콜이라 부름
프로그램을 실행하다 보면 함수를 실행하는 부분이 있음 
처음에 프로그램이 cpu에서 메인함수를 실행할떄는 메인 함수에 해당하는 인스트럭션을 실행할거임
다른 함수를 호출하면 점프를 할거임
if문에 만족 안하거나 그러면 메모리 위치를 점프 하게됌
반복문이라면 내려가다 올라가고 하는 방식으로 실행이됌
프로그램이 실행되다가 io요청을 하기 위해서 운영체제의 함수를 운영하는게 시스템콜이라고 설명을 했는데
그냥 메모리 주소를 바꿔서 되는게 아님
어떤식으로 운영체제 함수를 호출 하냐면
아까 디바이스 컨트로러들이 cpu에게 인터럽트를 걸수  잇다고 햇는대 그런식으로 호출을함
내가 내 프로그램을 호출하다가 io를 해야된다면 직접 주소 점프를 못함
나는 사용자 프로그램임 모드빗이 1로되잇음
io를 하기위해서는 운영체제로 해당하는 걸로 넘어가야됌
프로그램이 직접 인터럽트 라인을 실행하는 인터럽트를 실행함
인스트럭션 하나가 실행되고 나면 인터럽트 들어온게 잇는지 체크함
타이머가나 io가 인터럽트를 거는게 아니고 프로그램이 인터럽트를 요청하기 위해서 직접 걸수잇음
cpu는 다음인스트럭션을 실행하는게 아니고 인터럽트가 들어왓기 떄문에 모드빗이 0으로 바뀌고 cpu제어권이 os로 넘어감
디스크로 뭘 읽어오기 위해서 요청을 햇다면 os가 디스크 컨트롤러에게 뭘 가져오라고 요청을함
인터럽트는 하드웨어일꾼들이 정보 교신을 하기위해서 걸어줄수도 잇고 사요자 프로그램이 돌아가다가
내가 처리 못하고 운영체제에게 요청해야되는 상황에서도 인터럽트 라인을 세팅해서 os에게 cpu가 넘어갈수 있음
후자를 소프트웨어 인터럽트 라고 부름 다른말로 trap이라고 부름
소프트웨어적으로 인터럽트를 거는거임.
일반적으로는 io나 타이머가 거는 인터럽트를 뜻함
넓은 의미는 둘다 포함함

os는 항상 올바른 요청인지 그 파일에 대한 접근권한이 잇는건지 올바른 요청인 경우에 요청을 부탁함
그러면 io 컨트롤러는 일을함 그러면 cpu는 다른거한테 넘어가고
끝나면 하드웨어 인터럽트가 걸림
그래서 io를 하기 위해서 인터럽트가 두가지가 걸림
처음에는 프로그램이 io를하기위해 os에 시스템 콜을함 그럼 os가 device에게 시킴
시킨일이 끝나면 io 컨트롤러가 cpu에게 하드웨어 인터럽트를 검 

## 인터럽트(Interrupt)
- 인터럽트
    - 인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다
    - Interrupt(넓은 의미)
        - Interrupt(하드웨어 인터럽트): 하드웨어가 발생시킨 인터럽트
        - Trap(소프트웨어 인터럽트)
            - Exception: 프로그램이 오류를 범한 경우
            - System call: 프로그램이 커널 함수를 호출하는 경우
    - 인터럽트 관련 용어
        - 인터럽트 벡터
            - 해당 인터럽트의 처리 루틴 주소를 가지고 있음
            - 인터럽트 처리 루틴(=Interrupt Service Routine, 인터럽트 핸들러)
                - 해당 인터럽트를 처리하는 커널 함수

**현대의 운영체제는 인터럽트에 의해 구동됨**

## 시스템콜(System Call)
- 시스템 콜
    - 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것

각각의 인터럽트마다 운영체제가 무슨일을 해야하는지 운영체제 코드에 정의가 되어잇음
각 인터럽트가 처리해야되는 코드를 인터럽트 처리루틴이라고함
그 표시를 인터럽트 벡터라는 곳에 표시를 해둠
어떤 인터럽트를 처리해야되는지 주소를 적어둠

