---
layout: post
title: 그리디 알고리즘 소개
category: 알고리즘-문제풀이
tags: [문제풀이, 알고리즘, 그리디 알고리즘]
comments: true
---
<!----------------- 탬플릿
## forEach
### 설명
[MDN]()
### 문법
```javascript

```
### 예시
```javascript

```
------------------->

> 나동빈 저서의 이것이 코딩 테스트다 책을 읽고 정리했습니다.

# 그리디 알고리즘
- 가장 단순하면서도 강력한 문제 해결 방법
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법

### 거스름돈 문제
거스름돈으로 사용할 돈의 종류가 주어지고, 거슬러줘야 할돈이 N원 일때에 거슬러 줘야할 동전의 최소 개수를 구하는 문제이다.
거슬러야할 동전의 수를 최대한 작게 하려면 거슬러줘야 할 돈의 단위를 크게 할수록 적은 수의 동전으로 거슬러 줄 수 있다.
그러므로 가장 큰 단위의 동전으로 나누어서 몫을 저장하고 그다음 낮은 단위의 동전으로 계속적으로 나누어서 몫을 더하게 되면 거슬러줘야 할 최소의 동전 수를 구할 수있다.

위의 문제에서는 어렵지 않게 해결 방법을 생각해서 최적의 해를 찾아 볼수 있다.

### 큰 수의 법칙 
큰수의 법칙 문제는 다양한 수로 이루어진 배열이 있을떄 주어진 수를 M번 더하여 가장 큰 수를 만드는 법칙이다.
단, 배열의 특정한 인덱스에 해당하는 수를 K번 초과하여 더할수 없다는 조건이 있다.

이 문제를 해결하기 위해서는 주어진 수를 K번 더하여 제일 큰 수를 만들수 있는 방법을 생각 해 보아야 한다.
제일 큰수를 만들기 위해서는 배열의 제일 큰수를 가능한 한 많이 더하여야 한다.
하지만 이 문제에서는 특정 인덱스의 값을 K번 초과하여 더할 수 없기 때문에 최대값을 K번 더해주고 난 뒤에 그다음에 오는 큰수를 1번 더하고
다시 최대값을 더해주는 방법을 M번까지 반복하여 주어진 수로 최대 값을 구할 수 있다.

여기에서 중요하게 봐야 될 부분은 주어진 수의 배열에서 최대값과 그다음 큰수 이 두가지의 수만 사용한다는 것이다.
위에서 설명한거처럼 `(최대값 * K) + 그다음 큰수 ` 를 통하여 반복적으로 구할 값을 구할수 있고 이길이는 K+1이 된다.
위 값을 M / (K+1) 번 곱해준 뒤에 나머지가 존재 하는 경우에는 나머지만큼 큰수를 더해 주어야 하기 때문에 K*나머지를 해주어서 전부 더하면 정답을 얻을 수 있다.

### 숫자 카드 게임
숫자 카드 게임은 주어진 조건에 맞게 카드 한장을 뽑는 게임이다.

조건은 다음과 같다.
1. N*M 형태로 숫자가 쓰여진 카드가 놓여져 있다. 이때 N은 행 개수를 의미하며 M은 열 개수를 의미한다.
2. 먼저 뽑고자 한느 카드가 포함되어 있는 행을 선택한다.
3. 선택된 행에 포함된 카드중 가장 숫자가 낮은 카드를 뽑아야 한다.
4. 3번에서 뽑은 가장 낮은 수중에서 가장 높은 수를 최종적으로 선택한다.

이 문제는 각 행의 가장 낮은 수 중에서 가장 높은 수를 뽑는 문제이다.
해결방법은 각 행에서 가장 낮은 수를 찾고 그중에 가장 큰 수를 찾으면 된다.

### 1이 될 때까지
1이 될 때까지 문제는 N이 1이 될떄까지 다음의 두 과정중 하나를 반복적으로 수행해야 한다.
단, 2번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.

1. N에서 1을 뺀다.
2. N을 K로 나눈다.

N과 K 가 주어질때 최종적으로 연산을 한 횟수를 구하는 문제이다.

이 문제를 해결 하는 방법은 최대한 많이 나누는 것이다.
N을 K로 나눌수 있는 경우엔 나누고 나누지 못하는 경우에 1번 연산을 나누어 질 수 있을 때가지 수행하면 된다.

만약 N이 100억 이상의 큰수로 주어질 때에도 빠르게 동작 하도록 하려면 N이 K의 배수가 되도록 한번에 빼는 방식으로도 소스코드를 작성 할 수 있다.